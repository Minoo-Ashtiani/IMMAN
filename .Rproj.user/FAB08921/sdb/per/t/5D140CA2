{
    "collab_server" : "",
    "contents" : "#' @title IMMAN: Interlog protein network reconstruction, Mapping and ANalysis\n#'\n#' @description\n#' A function for reconstructing Interlog Protein Network (IPN) integrated\n#' from  Protein-protein Interaction Networks (PPIN) from different species. Users can overlay different\n#' PPINs to mine conserved common network between diverse species. It helps to retrieve\n#' IPN with different degrees of conservation to have better protein function\n#' prediction and PPIN analysis.\n#' @param fileNames a character vector, containing names of text files containing protein list for each species.\n#' The protein list of each species must be in a column without header and rownames in seperate \".txt\" files.\n#' The ProteinLists argument should be include at least two text file names addressing the protein list of each species\n#' which are in UniProt accession IDs format.\n#' @param Species_IDs a numeric vector; taxonomy ID for each organism which are provided in fileNames\n#' @param identityU numeric; value for selecting proteins whose alignment score is greater or equal than identityU\n#' @param substitutionMatrix a scoring substitution matrix to be used for alignment setting.\n#' @param gapOpening numeric; indicating the cost for opening a gap in the alignment\n#' @param gapExtension The incremental cost incurred along the length of the gap in the alignment\n#' @param BestHit logical; if TRUE describes a pair protein sequence among two different species\n#' which is the reciprocal best hit in sequence similarity analysis, whilst,\n#' if it is FALSE, indicates a nonreciprocal best hit\n#' @param coverage Number of connected proteins pairs in each Ortholog Protein Set (OPS) pair\n#' (termed as “coverage”) to\n#' reconstruct an edge of OPS pair in the IPN (Interlog Protein Network)\n#' @param NetworkShrinkage logical; if TRUE OPSs that are similar to each other would be merged.\n#' @param score_threshold numeric; STRINGdb score for protein protein interaction (PPI) selection in STRING database\n#' @param STRINGversion character; indicating which version of STRING database should program\n#' search in for the score of PPIs.\n#' @param InputDirectory By default is getwd(). You can set this parameter to indicate where\n#' the downloaded file from STRING should be saved.\n#' @details\n#'\n#' This function is specified to retrieve the interlog protein network shared across diverse species.\n#' For this aim, first we exceed orthology relationships among sequences from various species by iterating\n#' over any pair of input species, and using the Needleman-Wunsch alignment algorithm and a best reciprocal hit strategy to\n#' reach the orthologues through all versus all pairwise cross-species alignments. From orthology\n#' assignment, we derive Orthologous Protein sets (OPSs), an assortment of clusters of orthologues\n#' (maximum one per species) which will conform the nodes of the so-called Interolog Protein Network (IPN).\n#' We exceed n species-specific interlog protein networks from STRING database, where each node maps to a\n#' single OPS in the IPN, and distinguish the edges of the outcome IPN by choosing only edges linking nodes\n#' in the IPN that also are linked in at least k species-specific networks (where 'k' is set as a parameter).\n#'\n#' A scoring system is used by the alignment process, which can be described as a set of values specified for quantifying\n#' the likelihood of one residue that has been substituted by another in an alignment. The scoring systems used by\n#' alignment procedure is called a substitution matrix and it can be achieved from statistical analysis of residue substitution\n#' data from sets of reputable alignments of highly relevent sequences.\n#'\n#' Using identityU value which ranges from 0 to 100, user would be able to specialize how the IPNs should be larger or not.\n#' As the value of identityU gets higher, the algorithm will find much similar orthologs and vice versa.\n#'\n#' We used gapOpening and gapExtension arguments to figure numeric values of ortholog proteins.\n#' For matching alignments of proteins if we skip a protein, gapOpening argument would be incremented.\n#' The smaller the amount of gap, protein alignements are more similar to each other.\n#'\n#' The score_threshold argument is specified for evaluating the similarity values between two proteins\n#' in substitutionMatrix. It differs from 0 to 100, however, the common use ranges from 25 to 30.\n#'\n#' The transference of interactionn among orthologs of different species called the interlog approach.\n#'\n#' We used Besthit argument to reach proteins which has the most similarity in all versus all protein alignment.\n#'\n#' If an interaction was exist between each pair of proteins of OPSs, an edge would be linked in the IPN. The coverage_threshold\n#' specifies the number of interactions that are exist among pair of proteins of OPSs. It differs from 1 to number of species.\n#' As much as the value of coverage_threshold was high, the final IPN would be more robust and usually smaller.\n#'\n#' NetworkShrinkage argument determine whether two similar OPSs which have ortholog proteins in common should be merged or not.\n#' If it was TRUE the resulting IPN would be smaller.\n#'\n#' @seealso \\code{\\link[Biostrings]{PairwiseAlignments}}\n#' @return\n#' a list contaning four elements:\n#'\n#' IPNEdges : data.frame; Edges of resulted interlog protein network.\n#'\n#' IPNNodes : data.frame; Nodes of resulted interlog protein network.\n#' Each node represents an OPS which is a set of ortholog proteins.\n#'\n#' Network : list; Retrived PPINs of each input species.\n#'\n#' maps : list; It includes data.frames indicating STRING_id data base matched to their corresponding\n#' UNIPROT_AC. The number of data.frames is according to the the number of species.\n#'\n#' IPN : an igraph object representing the interlog protein network.\n#'\n#' @author Payman Nickchi, Abdollah Safari\n#' @examples\n#'\n#' fileNames = c(\"inst/ProteinList - Homo sapiens (Human).txt\",\"inst/ProteinList - Rattus norvegicus (Rat).txt\")\n#'\n#' List1_Species_ID = 9606  # taxonomy ID List1 Homo sapiens\n#' List2_Species_ID = 10116 # taxonomy ID List2 Rat\n#'\n#' Species_IDs  = c(List1_Species_ID, List2_Species_ID)\n#'\n#' # Set the parameters to run the analysis.\n#' # Here is a description of parameters in IMMAN. If you need more\n#' # information you can refer to the paper.\n#' # identityU: Cut off value for selecting proteins whose alignment score\n#' # is greater or equal than identityU\n#' # substitutionMatrix: Which scoring matrix to be used for alignment\n#' # setting gapOpening and gapExtension for alignment purposes\n#' # For NetworkShrinkage, coverage, and BestHit refer to paper\n#' # score_threshold:\n#' # STRINGversion: Indicated which version of STRING database should\n#' # program search in for the score of PPIs.\n#' identityU = 30\n#' substitutionMatrix = \"BLOSUM62\"\n#' gapOpening = -8\n#' gapExtension = -8\n#' NetworkShrinkage = FALSE\n#' coverage = 1\n#' BestHit = TRUE\n#' score_threshold = 400\n#' STRINGversion=\"10\"\n#'\n#' # Run the IMMAN function for the parameters\n#' output = IMMAN(fileNames, Species_IDs,\n#'                identityU, substitutionMatrix,\n#'               gapOpening, gapExtension, BestHit,\n#'               coverage, NetworkShrinkage,\n#'                score_threshold, STRINGversion,\n#'                InputDirectory = getwd())\n#'\n#' output$IPNEdges\n#' output$IPNNodes\n#' output$Networks\n#' output$Networks[[1]]\n#' output$maps\n#' output$maps[[2]]\n#' output$IPN\n#'\n#'\n#' @export\n#' @importFrom Biostrings pairwiseAlignment\n#' @importFrom Biostrings pid\n#' @importFrom seqinr read.fasta\n#' @importFrom igraph graph_from_data_frame\n#' @importFrom graphics plot\n\nIMMAN <- function(fileNames, Species_IDs,\n                 identityU, substitutionMatrix,\n                 gapOpening, gapExtension, BestHit,\n                 coverage, NetworkShrinkage,\n                 score_threshold, STRINGversion,\n                 InputDirectory = getwd()){\n\n  align <- function(pattern, subject, type){\n\n    p = pairwiseAlignment(pattern, subject, scoreOnly = FALSE,\n                          substitutionMatrix = substitutionMatrix,\n                          gapOpening = gapOpening,\n                          gapExtension = gapExtension)\n\n    return( pid(p  , type = \"PID1\") )\n  }\n\n  combination3 <- function(L1, L2, L3) {\n\n    # res1.temp <- unlist(Lists[1])\n    # res2.temp <- unlist(Lists[2])\n    # res3.temp <- unlist(Lists[3])\n\n    res1.temp <- L1\n    res2.temp <- L2\n    res3.temp <- L3\n\n    # combination\n    x.names <- character(0)\n    y.names <- character(0)\n    z.names <- character(0)\n    for (i in 1 : nrow(res1.temp)) {\n\n      if (sum(res1.temp[i, ]) == 1) {\n        vec.temp <- res2.temp[i, ] * res3.temp[(res1.temp[i,] == 1), ]\n        if (sum(vec.temp) >= 1) {\n          x.names <- c(x.names, rep(rownames(res1.temp)[i], sum(vec.temp)))\n          y.names <- c(y.names, rep(rownames(res3.temp)[(res1.temp[i,] == 1)], sum(vec.temp)))\n          z.names <- c(z.names, colnames(res3.temp)[vec.temp == 1])\n        }\n      }\n\n      if (sum(res1.temp[i, ]) > 1) {\n        list.temp <- apply(cbind(res3.temp[(res1.temp[i,] == 1), ], which(res1.temp[i,] == 1)), 1,\n                           function(x) {\n                             vec.temp <- res2.temp[i, ] * x[-length(x)]\n                             if (sum(vec.temp) >= 1) {\n                               x.names.temp <- rep(rownames(res1.temp)[i], sum(vec.temp))\n                               y.names.temp <- rep(rownames(res3.temp)[x[length(x)]], sum(vec.temp))\n                               z.names.temp <- colnames(res3.temp)[vec.temp == 1]\n                               list(xx = x.names.temp,\n                                    yy = y.names.temp,\n                                    zz = z.names.temp)\n                             }\n                           })\n\n        x.names <- c(x.names, unlist(lapply(list.temp, function(x) unlist(x[1]))))\n        y.names <- c(y.names, unlist(lapply(list.temp, function(x) unlist(x[2]))))\n        z.names <- c(z.names, unlist(lapply(list.temp, function(x) unlist(x[3]))))\n      }\n    }\n\n    return(list(x.names, y.names, z.names))\n  }\n\n  if(is.element(FALSE,file.exists(fileNames)) %in% FALSE) {\n    files<-list()\n    ProteinList<-list()\n    for (i in 1:length(fileName)) {\n      files[[i]] <- read.csv(fileName[i],\n                             header = F)\n      ProteinList[[i]]<-as.character(as.data.frame(files[[i]])$V1)\n    }\n  }\n  else stop(\"Error: The file name does not exist in the diretory path\")\n\n  Species_IDs<-sapply(Species_IDs,list)\n\n  list_num <- length(ProteinLists)\n\n  for (i in 1 : list_num) {\n    if( is.character(ProteinLists[[i]]) == \"FALSE\" ) {\n      stop(paste(\"Error: ProteinList\", i,\" should be a vector type of character\", sep = \"\"))\n    }\n  }\n\n  if( !(coverage %in% 1:4) ){\n    stop(\"Error: Coverage should be between 1 up to 4\")\n  }\n\n\n  ## Print status\n  message(\"Step 1/4:Downloading amino acid sequences...\")\n  PS_list <- list()\n  for (i in 1 : list_num) {\n    message(paste(\"Downloading amino acid sequences of List\", i, sep = \"\"))\n    PS_list <- c(PS_list, list(apply(data.frame(Protein = ProteinLists[[i]]), 1,\n                                     function (x) {\n                                       as.character(read.fasta(file =\n                                                                 paste(\"http://www.uniprot.org/uniprot/\",\n                                                                       x,\".fasta\",sep=\"\"),\n                                                               seqtype =\"AA\", as.string = TRUE,\n                                                               set.attributes = FALSE))\n                                     })))\n  }\n\n  names(PS_list) <- c(paste(\"PS\", seq(1 : list_num), sep = \"\"))\n\n\n  message(\"Step 2/4: Alignment...\")\n\n  temp_list <- list()\n  res_list <- list()\n  for (i in 1 : (list_num - 1)) {\n    for (j in (i + 1) : list_num) {\n      message(paste(\"Align List\", i,\" with List\", j, sep = \"\"))\n      unbinres = t(apply(as.matrix(PS_list[[i]], ncol = 1), 1, function (x) {\n        apply(as.matrix(PS_list[[j]], ncol = 1), MARGIN = 1, FUN=align, x)\n      }))\n      res = matrix(as.numeric(unbinres > identityU), nrow(unbinres), ncol(unbinres))\n      rownames(res) <- ProteinLists[[i]]\n      colnames(res) <- ProteinLists[[j]]\n      indx = res == 1\n      temp_list = c(temp_list, list(indx * unbinres))\n      res[res == 1] <- 0\n      res_list <- c(res_list, list(res))\n    }\n  }\n\n  pair_num <- list_num * (list_num - 1) / 2\n  names(temp_list) <- paste(\"temp\", seq(1 : pair_num), sep = \"\")\n  names(res_list) <- paste(\"res\", seq(1 : pair_num), sep = \"\")\n\n  # temp_list_backup <- temp_list\n  # res_list_backup <- res_list\n  #\n  # temp_list <- temp_list_backup\n  # res_list  <- res_list_backup\n\n  if (BestHit == TRUE) {\n    for (i in 1 : pair_num) {\n      temp_list[[i]] <- apply(temp_list[[i]], 1, function(x) {\n        ind.temp <- which(x == max(x))\n        if (length(ind.temp) > 1) colnames(temp_list[[i]])[ind.temp][apply(temp_list[[i]][, ind.temp], 2, max) == x[ind.temp]]\n        else colnames(temp_list[[i]])[ind.temp][max(temp_list[[i]][, ind.temp]) == x[ind.temp]]\n      })\n\n      for (j in 1 : length(temp_list[[i]])) {\n        if (length(unlist(temp_list[[i]][j])) > 0) res_list[[i]][names(temp_list[[i]][j]), unlist(temp_list[[i]][j])] <- 1\n      }\n    }\n  }\n  if( BestHit == FALSE){\n    for (i in 1 : pair_num) {\n      temp_list[[i]] <- apply(temp[[i]], 1, function(x) {\n        colnames(temp[[i]])[x != 0]\n      })\n\n      for (j in 1 : length(temp_list[[i]])) {\n        if (length(unlist(temp_list[[i]][j])) > 0) res_list[[i]][names(temp_list[[i]][j]), unlist(temp_list[[i]][j])] <- 1\n      }\n    }\n  }\n\n  message(\"Step 3/4: Detection in STRING...\")\n\n  string_db_list <- list()\n  map_list <- list()\n  for (i in 1 : list_num) {\n    string_db_list <- c(string_db_list, list(STRINGdb$new(version = STRINGversion,\n                                                          species= Species_IDs[[i]],\n                                                          score_threshold = score_threshold,\n                                                          input_directory = getwd())))\n  }\n\n  if (list_num == 4) {\n    # 1-2\n    x.temp1 <- rep(names(temp_list[[1]]), unlist(lapply(temp_list[[1]], length)))\n    y.temp1 <- unlist(temp_list[[1]])\n    # 1-3\n    x.temp2 <- rep(names(temp_list[[2]]), unlist(lapply(temp_list[[2]], length)))\n    z.temp1 <- unlist(temp_list[[2]])\n    # 1-4\n    x.temp3 <- rep(names(temp_list[[3]]), unlist(lapply(temp_list[[3]], length)))\n    w.temp1 <- unlist(temp_list[[3]])\n    # 2-3\n    y.temp2 <- rep(names(temp_list[[4]]), unlist(lapply(temp_list[[4]], length)))\n    z.temp2 <- unlist(temp_list[[4]])\n    # 2-4\n    y.temp3 <- rep(names(temp_list[[5]]), unlist(lapply(temp_list[[5]], length)))\n    w.temp2 <- unlist(temp_list[[5]])\n    # 3-4\n    z.temp3 <- rep(names(temp_list[[6]]), unlist(lapply(temp_list[[6]], length)))\n    w.temp3 <- unlist(temp_list[[6]])\n\n    # x-y-z\n    list.names1 <- combination3(res_list[[1]], res_list[[2]], res_list[[4]])\n    x.names1 <- unlist(list.names1[1])\n    y.names1 <- unlist(list.names1[2])\n    z.names1 <- unlist(list.names1[3])\n    mat.xyz1 <- cbind(x.names1, y.names1, z.names1)\n\n    # x-y-w\n    list.names2 <- combination3(res_list[[1]], res_list[[3]], res_list[[5]])\n    x.names2 <- unlist(list.names2[1])\n    y.names2 <- unlist(list.names2[2])\n    w.names2 <- unlist(list.names2[3])\n    mat.xyw1 <- cbind(x.names2, y.names2, w.names2)\n\n    x.inters1 <- intersect(unique(x.names1), unique(x.names2))\n    y.inters1 <- lapply(unique(x.inters1), function(x) {\n      y.inters1 <- intersect(unique(y.names1[x.names1 == x]), unique(y.names2[x.names2 == x])) })\n\n    mat.xyz2 <- matrix(NA, ncol = 3, nrow = 1)\n    mat.xyw2 <- matrix(NA, ncol = 3, nrow = 1)\n    for (i in 1 : length(x.inters1)) {\n      mat.xyz2 <- rbind(mat.xyz2, mat.xyz1[mat.xyz1[ , 2] %in% unlist(y.inters1[i]), ])\n      mat.xyw2 <- rbind(mat.xyw2, mat.xyw1[(mat.xyw1[, 1] == x.inters1[i]) & (mat.xyw1[ , 2] %in% unlist(y.inters1[i])), ])\n    }\n    mat.xyz2 <- mat.xyz2[-1, ]\n    mat.xyw2 <- mat.xyw2[-1, ]\n\n    x.inters2 <- intersect(unique(mat.xyz2[,1]), unique(unique(mat.xyw2[,1])))\n    y.inters2 <- lapply(unique(x.inters2), function(x) {\n      y.inters2 <- intersect(unique(mat.xyz2[mat.xyz2[,1] == x, 2]), unique(mat.xyw2[mat.xyw2[, 1] == x, 2])) })\n\n    # Final lists\n    mat.xyzw <- matrix(NA, nrow = 1, ncol = 4)\n    for (i in 1 : length(y.inters2)) {\n      for (j in 1 : length(y.inters2[[i]])) {\n        z.temp <- mat.xyz2[(mat.xyz2[,1] == x.inters2[i]) & (mat.xyz2[,2] == y.inters2[[i]][j]), 3]\n        w.temp <- mat.xyw2[(mat.xyw2[,1] == x.inters2[i]) & (mat.xyw2[,2] == y.inters2[[i]][j]), 3]\n        res6.temp.sub <- matrix(res_list[[6]][z.temp,w.temp], ncol = length(w.temp), nrow = length(z.temp), T)\n        sum.temp <- sum(res6.temp.sub)\n        if (sum.temp > 0) {\n          temp.mat <- matrix(NA, nrow = 1, ncol = 2)\n          for (k in 1 : length(z.temp)) {\n            temp.mat <- rbind(temp.mat, t(rbind(rep(z.temp[k], sum(res6.temp.sub[k,])),\n                                                w.temp[res6.temp.sub[k,] == 1])))\n          }\n          temp.mat <- matrix(temp.mat[-1, ], ncol = 2, nrow = nrow(temp.mat) - 1)\n          mat.xyzw <- rbind(mat.xyzw,\n                            cbind(matrix(c(rep(x.inters2[i], sum.temp),\n                                           rep(y.inters1[[i]][j], sum.temp)), ncol = 2, nrow = sum.temp),\n                                  temp.mat))\n        }\n      }\n    }\n    mat.xyzw <- mat.xyzw[-1, ]\n\n\n    message(\"Detecting List1 in STRING\")\n    map1 = string_db_list[[1]]$map( data.frame(UNIPROT_AC = unique(mat.xyzw[, 1])) ,\n                                    \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n    if( nrow(map1) == 0 ) {\n      print(ProteinLists[[1]])\n      stop(\"Error: none of the proteins in list1 mapped to STRING ID\")\n    }\n\n    message(\"Detecting List2 in STRING\")\n    map2 = string_db_list[[2]]$map(data.frame(UNIPROT_AC = unique(mat.xyzw[, 2])) ,\n                                   \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n    if( nrow(map2) == 0 ) {\n      print(ProteinLists[[2]])\n      stop(\"Error: none of the proteins in list2 mapped to STRING ID\")\n    }\n\n    message(\"Detecting List3 in STRING\")\n    map3 = string_db_list[[3]]$map( data.frame(UNIPROT_AC = unique(mat.xyzw[, 3])) ,\n                                    \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n    if( nrow(map3) == 0 ) {\n      print(ProteinLists[[3]])\n      stop(\"Error: none of the proteins in list3 mapped to STRING ID\")\n    }\n\n    message(\"Detecting List4 in STRING\")\n    map4 = string_db_list[[4]]$map( data.frame(UNIPROT_AC = unique(mat.xyzw[, 4])) ,\n                                    \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n    if( nrow(map4) == 0 ) {\n      print(ProteinLists[[4]])\n      stop(\"Error: none of the proteins in list4 mapped to STRING ID\")\n    }\n\n    OPS = data.frame(node1 = mat.xyzw[, 1], node2 = mat.xyzw[, 2], node3 = mat.xyzw[, 3], node4 = mat.xyzw[, 4])\n    OPS <- merge(OPS, map1, by.y = \"UNIPROT_AC\", by.x = \"node1\")\n    colnames(OPS)[5] <- \"STRING_id_1\"\n    OPS <- merge(OPS, map2, by.y = \"UNIPROT_AC\", by.x = \"node2\")\n    colnames(OPS)[6] <- \"STRING_id_2\"\n    OPS <- merge(OPS, map3, by.y = \"UNIPROT_AC\", by.x = \"node3\")\n    colnames(OPS)[7] <- \"STRING_id_3\"\n    OPS <- merge(OPS, map4, by.y = \"UNIPROT_AC\", by.x = \"node4\")\n    colnames(OPS)[8] <- \"STRING_id_4\"\n\n    OPS <- data.frame(node1 = OPS[, 5], node2 = OPS[, 6], node3 = OPS[, 7], node4 = OPS[, 8])\n\n    OPSLabel = c()\n    flag.temp <- T\n    if (nrow(OPS) > 10) {OPSLabel = c(OPSLabel, paste(\"OPS000\", c(1 : 9), sep=\"\"))\n    } else {\n      OPSLabel = c(OPSLabel, paste(\"OPS000\", c(1 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 100) {OPSLabel = c(OPSLabel, paste(\"OPS00\", c(10 : 99), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel, paste(\"OPS00\", c(10 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 1000) {OPSLabel = c(OPSLabel, paste(\"OPS00\", c(100 : 999), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel, paste(\"OPS00\", c(100 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 10000) {OPSLabel = c(OPSLabel, paste(\"OPS00\", c(1000 : 9999), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel, paste(\"OPS00\", c(1000 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n\n    OPS <- cbind(OPS, OPSLabel = OPSLabel)\n\n\n    message(\"Step 4/4: Retrieving String Network...\")\n\n    message(\"Retrieving List1\")\n    Network1 = data.frame(from = string_db_list[[1]]$get_interactions(OPS$node1)$from,\n                          to = string_db_list[[1]]$get_interactions(OPS$node1)$to)\n    if(nrow(Network1) == 0){\n      print(ProteinLists[[1]])\n      stop(\"Error: No interaction was detected for ProteinList1\")\n    }\n\n    message(\"Retrieving List2\")\n    Network2 = data.frame(from = string_db_list[[2]]$get_interactions(OPS$node2)$from,\n                          to = string_db_list[[2]]$get_interactions(OPS$node2)$to)\n    if(nrow(Network2) == 0){\n      print(ProteinLists[[2]])\n      stop(\"Error: No interaction was detected for ProteinList2\")\n    }\n\n    message(\"Retrieving List3\")\n    Network3 = data.frame(from = string_db_list[[3]]$get_interactions(OPS$node3)$from,\n                          to = string_db_list[[3]]$get_interactions(OPS$node3)$to)\n    if(nrow(Network3) == 0){\n      print(ProteinLists[[3]])\n      stop(\"Error: No interaction was detected for ProteinList3\")\n    }\n\n    message(\"Retrieving List4\")\n    Network4 = data.frame(from = string_db_list[[4]]$get_interactions(OPS$node4)$from,\n                          to = string_db_list[[4]]$get_interactions(OPS$node4)$to)\n    if(nrow(Network4) == 0){\n      print(ProteinLists[[4]])\n      stop(\"Error: No interaction was detected for ProteinList4\")\n    }\n\n    message(\"Producing IPN...\")\n\n    node1 = c()\n    node2 = c()\n    l = nrow(OPS)\n    # i = 1\n    for (i in 1 : (l - 1)) {\n      node.temp <- apply(OPS[c((i + 1) : l), ], 1, function(x){\n        a = c(as.character(OPS[i,1]) , as.character(x[1]))\n        b = c(as.character(OPS[i,2]) , as.character(x[2]))\n        c = c(as.character(OPS[i,3]) , as.character(x[3]))\n        d = c(as.character(OPS[i,4]) , as.character(x[4]))\n\n        cond1 = ifelse(nrow(Network1[((Network1$from == a[1]) & (Network1$to) == a[2]), ]) != 0 |\n                         nrow(Network1[((Network1$from == a[2]) & (Network1$to) == a[1]), ]) != 0, TRUE, FALSE)\n        cond2 = ifelse(nrow(Network2[((Network2$from == b[1]) & (Network2$to) == b[2]), ]) != 0 |\n                         nrow(Network2[((Network2$from == b[2]) & (Network2$to) == b[1]), ]) != 0, TRUE, FALSE)\n        cond3 = ifelse(nrow(Network3[((Network3$from == c[1]) & (Network3$to) == c[2]), ]) != 0 |\n                         nrow(Network3[((Network3$from == c[2]) & (Network3$to) == c[1]), ]) != 0, TRUE, FALSE)\n        cond4 = ifelse(nrow(Network4[((Network4$from == d[1]) & (Network4$to) == d[2]), ]) != 0 |\n                         nrow(Network4[((Network4$from == d[2]) & (Network4$to) == d[1]), ]) != 0, TRUE, FALSE)\n\n        if (((cond1 + cond2 + cond3 + cond4 == 1) & (coverage == 1)) |\n            ((cond1 + cond2 + cond3 + cond4 == 2) & (coverage == 2)) |\n            ((cond1 + cond2 + cond3 + cond4 == 3) & (coverage == 3)) |\n            ((cond1 + cond2 + cond3 + cond4 == 4) & (coverage == 4))) {\n          return(c(as.character(OPS[i, 5]), as.character(x[5])))\n        }\n\n        if ((NetworkShrinkage == FALSE)) {\n          t1 = as.character(OPS[i, 1]) == as.character(x[1])\n          t2 = as.character(OPS[i, 2]) == as.character(x[2])\n          t3 = as.character(OPS[i, 3]) == as.character(x[3])\n          t4 = as.character(OPS[i, 4]) == as.character(x[4])\n\n          mycond = cond1 + cond2 + cond3 + cond4\n          TT = t1 + t2 + t3 + t4\n          if (TT + mycond >= coverage){\n            return(c(as.character(OPS[i, 5]), as.character(x[5])))\n          }\n\n        }\n      })\n\n      if (! is.null(node.temp)) {\n        node1 <- c(node1, unlist(node.temp)[seq(1, length(unlist(node.temp)), 2)])\n        node2 <- c(node2, unlist(node.temp)[seq(2, length(unlist(node.temp)), 2)])\n      }\n    }\n\n    EdgeList = data.frame(node1 , node2)  #, node3, node4)\n\n    map_list <- list(map1, map2, map3, map4)\n    network_list <- list(Network1, Network2, Network3, Network4)\n  }\n  if (list_num == 3) {\n    # 1-2\n    x.temp1 <- rep(names(temp_list[[1]]), unlist(lapply(temp_list[[1]], length)))\n    y.temp1 <- unlist(temp_list[[1]])\n    # 1-3\n    x.temp2 <- rep(names(temp_list[[2]]), unlist(lapply(temp_list[[2]], length)))\n    z.temp1 <- unlist(temp_list[[2]])\n    # 2-3\n    y.temp2 <- rep(names(temp_list[[3]]), unlist(lapply(temp_list[[3]], length)))\n    z.temp2 <- unlist(temp_list[[3]])\n\n    # combination\n    x.names <- character(0)\n    y.names <- character(0)\n    z.names <- character(0)\n    for (i in 1 : nrow(res_list[[1]])) {\n\n      if (sum(res_list[[1]][i, ]) == 1) {\n        vec.temp <- res_list[[2]][i, ] * res_list[[3]][(res_list[[1]][i,] == 1), ]\n        if (sum(vec.temp) >= 1) {\n          x.names <- c(x.names, rep(rownames(res_list[[1]])[i], sum(vec.temp)))\n          y.names <- c(y.names, rep(rownames(res_list[[3]])[(res_list[[1]][i,] == 1)], sum(vec.temp)))\n          z.names <- c(z.names, colnames(res_list[[3]])[vec.temp == 1])\n        }\n      }\n\n      if (sum(res_list[[1]][i, ]) > 1) {\n        list.temp <- apply(cbind(res_list[[3]][(res_list[[1]][i,] == 1), ], which(res_list[[1]][i,] == 1)), 1,\n                           function(x) {\n                             vec.temp <- res_list[[2]][i, ] * x[-length(x)]\n                             if (sum(vec.temp) >= 1) {\n                               x.names.temp <- rep(rownames(res_list[[1]])[i], sum(vec.temp))\n                               y.names.temp <- rep(rownames(res_list[[3]])[x[length(x)]], sum(vec.temp))\n                               z.names.temp <- colnames(res_list[[3]])[vec.temp == 1]\n                               list(xx = x.names.temp,\n                                    yy = y.names.temp,\n                                    zz = z.names.temp)\n                             }\n                           })\n\n        x.names <- c(x.names, unlist(lapply(list.temp, function(x) unlist(x[1]))))\n        y.names <- c(y.names, unlist(lapply(list.temp, function(x) unlist(x[2]))))\n        z.names <- c(z.names, unlist(lapply(list.temp, function(x) unlist(x[3]))))\n      }\n    }\n\n\n    message(\"Detecting List1 in STRING\")\n\n    map1 = string_db_list[[1]]$map( data.frame(UNIPROT_AC = unique(x.names)) ,\n                                    \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n\n\n    if( nrow(map1) == 0 ) {\n      stop(\"Error: none of the proteins in list1 mapped to STRING ID\")\n    }\n\n\n    message(\"Detecting List2 in STRING\")\n\n    map2 = string_db_list[[2]]$map( data.frame(UNIPROT_AC = unique(y.names)) ,\n                                    \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n\n    if( nrow(map2) == 0 ) {\n      stop(\"Error: none of the proteins in list2 mapped to STRING ID\")\n    }\n\n\n    message(\"Detecting List3 in STRING\")\n\n    map3 = string_db_list[[3]]$map(data.frame(UNIPROT_AC = unique(z.names)) ,\n                                   \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n\n    if( nrow(map3) == 0 ) {\n      stop(\"Error: none of the proteins in list3 mapped to STRING ID\")\n    }\n\n    OPS = data.frame(node1 = x.names, node2 = y.names, node3 = z.names)\n    OPS <- merge(OPS, map1, by.y = \"UNIPROT_AC\", by.x = \"node1\")\n    colnames(OPS)[4] <- \"STRING_id_1\"\n    OPS <- merge(OPS, map2, by.y = \"UNIPROT_AC\", by.x = \"node2\")\n    colnames(OPS)[5] <- \"STRING_id_2\"\n    OPS <- merge(OPS, map3, by.y = \"UNIPROT_AC\", by.x = \"node3\")\n    colnames(OPS)[6] <- \"STRING_id_3\"\n\n    OPS <- data.frame(node1 = OPS[, 4], node2 = OPS[, 5], node3 = OPS[, 6])\n\n    OPSLabel = c()\n    flag.temp <- T\n    if (nrow(OPS) > 10) {OPSLabel = c(OPSLabel,paste(\"OPS000\", c(1 : 9), sep=\"\"))\n    } else {\n      OPSLabel = c(OPSLabel,paste(\"OPS000\", c(1 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 100) {OPSLabel = c(OPSLabel,paste(\"OPS00\", c(10 : 99), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel,paste(\"OPS00\", c(10 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 1000) {OPSLabel = c(OPSLabel,paste(\"OPS00\", c(100 : 999), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel,paste(\"OPS00\", c(100 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 10000) {OPSLabel = c(OPSLabel,paste(\"OPS00\", c(1000 : 9999), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel,paste(\"OPS00\", c(1000 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n\n    OPS <- cbind(OPS, OPSLabel = OPSLabel)\n\n\n    message(\"Step 4/4: Retrieving String Network...\")\n\n    message(\"Retrieving List1\")\n    Network1 = data.frame(from = string_db_list[[1]]$get_interactions(OPS$node1)$from,\n                          to = string_db_list[[1]]$get_interactions(OPS$node1)$to)\n    if(nrow(Network1) == 0){\n      print(ProteinLists[[1]])\n      stop(\"Error: No interaction was detected for ProteinList1\")\n    }\n\n    message(\"Retrieving List2\")\n    Network2 = data.frame(from = string_db_list[[2]]$get_interactions(OPS$node2)$from,\n                          to = string_db_list[[2]]$get_interactions(OPS$node2)$to)\n    if(nrow(Network2) == 0){\n      print(ProteinLists[[2]])\n      stop(\"Error: No interaction was detected for ProteinList2\")\n    }\n\n    message(\"Retrieving List3\")\n    Network3 = data.frame(from = string_db_list[[3]]$get_interactions(OPS$node3)$from,\n                          to = string_db_list[[3]]$get_interactions(OPS$node3)$to)\n    if(nrow(Network3) == 0){\n      print(ProteinLists[[3]])\n      stop(\"Error: No interaction was detected for ProteinList3\")\n    }\n\n\n    message(\"Producing IPN...\")\n\n    node1 = c()\n    node2 = c()\n    l = nrow(OPS)\n\n    # i = 1\n    for (i in 1 : (l - 1)) {\n      node.temp <- apply(OPS[c((i + 1) : l), ], 1, function(x){\n        a = c(as.character(OPS[i,1]) , as.character(x[1]))\n        b = c(as.character(OPS[i,2]) , as.character(x[2]))\n        c = c(as.character(OPS[i,3]) , as.character(x[3]))\n\n        cond1 = ifelse(nrow(Network1[((Network1$from == a[1]) & (Network1$to) == a[2]), ]) != 0 |\n                         nrow(Network1[((Network1$from == a[2]) & (Network1$to) == a[1]), ]) != 0, TRUE, FALSE)\n        cond2 = ifelse(nrow(Network2[((Network2$from == b[1]) & (Network2$to) == b[2]), ]) != 0 |\n                         nrow(Network2[((Network2$from == b[2]) & (Network2$to) == b[1]), ]) != 0, TRUE, FALSE)\n        cond3 = ifelse(nrow(Network3[((Network3$from == c[1]) & (Network3$to) == c[2]), ]) != 0 |\n                         nrow(Network3[((Network3$from == c[2]) & (Network3$to) == c[1]), ]) != 0, TRUE, FALSE)\n\n        if (((cond1 + cond2 + cond3 == 1) & (coverage == 1)) |\n            ((cond1 + cond2 + cond3 == 2) & (coverage == 2)) |\n            ((cond1 + cond2 + cond3 == 3) & (coverage ==3))) {\n          return(c(as.character(OPS[i,4]), as.character(x[4])))\n        }\n\n        if ((NetworkShrinkage == FALSE)) {\n          t1 = as.character(OPS[i,1]) == as.character(x[1])\n          t2 = as.character(OPS[i,2]) == as.character(x[2])\n          t3 = as.character(OPS[i,3]) == as.character(x[3])\n\n          mycond = cond1 + cond2 + cond3\n          TT = t1 + t2 + t3\n          if (TT+mycond >= coverage){\n            return(c(as.character(OPS[i,4]), as.character(x[4])))\n          }\n\n        }\n      })\n\n      if (! is.null(node.temp)) {\n        node1 <- c(node1, unlist(node.temp)[seq(1, length(unlist(node.temp)), 2)])\n        node2 <- c(node2, unlist(node.temp)[seq(2, length(unlist(node.temp)), 2)])\n      }\n    }\n\n    EdgeList = data.frame(node1 , node2) #, node3)\n\n    map_list <- list(map1, map2, map3)\n    network_list <- list(Network1, Network2, Network3)\n  }\n  if (list_num == 2) {\n    x <- rep(names(temp_list[[1]]), unlist(lapply(temp_list[[1]], length)))\n    xperim = unlist(temp_list[[1]])\n\n    message(\"Detecting List1 in STRING\")\n    map1 = string_db_list[[1]]$map(data.frame(UNIPROT_AC = unique(x)) ,\n                                   \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n\n    if ( nrow(map1) == 0 ) {\n      stop(\"Error: none of the proteins in list1 mapped to STRING ID\")\n    }\n\n    message(\"Detecting List2 in STRING\")\n    map2 = string_db_list[[2]]$map( data.frame(UNIPROT_AC = unique(xperim)) ,\n                                    \"UNIPROT_AC\" , removeUnmappedRows = TRUE)\n\n    if (nrow(map2) == 0) {\n      stop(\"Error: none of the proteins in list2 mapped to STRING ID\")\n    }\n\n    OPS = data.frame(node1 = x, node2 = xperim)\n    OPS <- merge(OPS, map1, by.y = \"UNIPROT_AC\", by.x = \"node1\")\n    colnames(OPS)[3] <- \"STRING_id_1\"\n    OPS <- merge(OPS, map2, by.y = \"UNIPROT_AC\", by.x = \"node2\")\n    colnames(OPS)[4] <- \"STRING_id_2\"\n\n    OPS <- data.frame(node1 = OPS[, 3], node2 = OPS[, 4])\n\n    OPSLabel = c()\n    flag.temp <- T\n    if (nrow(OPS) > 10) {OPSLabel = c(OPSLabel, paste(\"OPS000\", c(1 : 9), sep=\"\"))\n    } else {\n      OPSLabel = c(OPSLabel,paste(\"OPS000\", c(1 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 100) {OPSLabel = c(OPSLabel, paste(\"OPS00\", c(10 : 99), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel, paste(\"OPS00\", c(10 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 1000) {OPSLabel = c(OPSLabel, paste(\"OPS00\", c(100 : 999), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel,paste(\"OPS00\", c(100 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n    if (nrow(OPS) > 10000) {OPSLabel = c(OPSLabel,paste(\"OPS00\", c(1000 : 9999), sep=\"\"))\n    } else {\n      if (flag.temp) OPSLabel = c(OPSLabel,paste(\"OPS00\", c(1000 : nrow(OPS)), sep=\"\"))\n      flag.temp <- F\n    }\n\n    OPS <- cbind(OPS, OPSLabel = OPSLabel)\n\n    message(\"Step 4/4: Retrieving String Network...\")\n\n    message(\"Retrieving List1\")\n    Network1 = data.frame(from = string_db_list[[1]]$get_interactions(OPS$node1)$from,\n                          to = string_db_list[[1]]$get_interactions(OPS$node1)$to)\n\n    if (nrow(Network1) == 0) {\n      print(ProteinLists[[1]])\n      stop(\"Error: No STRING network was detected for ProteinList1\")\n    }\n\n    message(\"Retrieving List2\")\n    Network2 = data.frame(from = string_db_list[[2]]$get_interactions(OPS$node2)$from,\n                          to = string_db_list[[2]]$get_interactions(OPS$node2)$to)\n\n    if (nrow(Network2) == 0) {\n      print(ProteinLists[[2]])\n      stop(\"Error: No STRING network was detected for ProteinList2\")\n    }\n\n    message(\"Producing IPN...\")\n\n    node1 = c()\n    node2 = c()\n    l = nrow(OPS)\n\n    # i = 1\n    for (i in 1 : (l - 1)) {\n      node.temp <- apply(OPS[c((i + 1) : l), ], 1, function(x){\n        a = c(as.character(OPS[i,1]) , as.character(x[1]))\n        b = c(as.character(OPS[i,2]) , as.character(x[2]))\n\n        cond1 = ifelse(nrow(Network1[((Network1$from == a[1]) & (Network1$to) == a[2]), ]) != 0 |\n                         nrow(Network1[((Network1$from == a[2]) & (Network1$to) == a[1]), ]) != 0, TRUE, FALSE)\n        cond2 = ifelse(nrow(Network2[((Network2$from == b[1]) & (Network2$to) == b[2]), ]) != 0 |\n                         nrow(Network2[((Network2$from == b[2]) & (Network2$to) == b[1]), ]) != 0, TRUE, FALSE)\n\n        if (((cond1+cond2 == 1) & (coverage == 1)) | ((cond1+cond2 == 2) & (coverage == 2))) {\n          return(c(as.character(OPS[i,3]), as.character(x[3])))\n        }\n\n        if ((NetworkShrinkage == FALSE)) {\n          t1 = as.character(OPS[i,1]) == as.character(x[1])\n          t2 = as.character(OPS[i,2]) == as.character(x[2])\n\n          mycond = cond1 + cond2\n          TT = t1 + t2\n          if (TT+mycond >= coverage){\n            return(c(as.character(OPS[i,3]), as.character(x[3])))\n          }\n\n        }\n      })\n\n      if (! is.null(node.temp)) {\n        node1 <- c(node1, unlist(node.temp)[seq(1, length(unlist(node.temp)), 2)])\n        node2 <- c(node2, unlist(node.temp)[seq(2, length(unlist(node.temp)), 2)])\n      }\n    }\n\n    EdgeList = data.frame(node1 , node2)\n\n    map_list <- list(map1, map2)\n    network_list <- list(Network1, Network2)\n  }\n\n\n  if (nrow(EdgeList) != 0) {\n    IPN = graph_from_data_frame(d = EdgeList, directed = FALSE)\n    reslist = list(IPNEdges = EdgeList , IPNNodes = OPS,\n                   Networks = network_list,\n                   maps = map_list)\n    plot(IPN)\n    message(\"DONE!\")\n    return(reslist)\n  }\n\n  if (nrow(EdgeList) == 0) {\n    reslist = list(IPNEdges = EdgeList , IPNNodes = OPS,\n                   Networks = network_list,\n                   maps = map_list)\n    message(\"DONE! But EdgeList is empty!\")\n    return(reslist)\n  }\n}\n",
    "created" : 1503694630258.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2531219567",
    "id" : "5D140CA2",
    "lastKnownWriteTime" : 1503694556,
    "last_content_update" : 1503694556,
    "path" : "C:/Users/MINoOo/Desktop/IMMAN/IMMAN/R/IMMAN.R",
    "project_path" : "R/IMMAN.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}