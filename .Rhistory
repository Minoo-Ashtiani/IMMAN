if (sum(res_list[[1]][i, ]) > 1) {
list_tem <- apply(cbind(res_list[[3]][(res_list[[1]][i,] == 1), ], which(res_list[[1]][i,] == 1)), 1,
function(x) {
vec_tem <- res_list[[2]][i, ] * x[-length(x)]
if (sum(vec_tem) >= 1) {
x.names_tem <- rep(rownames(res_list[[1]])[i], sum(vec_tem))
y.names_tem <- rep(rownames(res_list[[3]])[x[length(x)]], sum(vec_tem))
z.names_tem <- colnames(res_list[[3]])[vec_tem == 1]
list(xx = x.names_tem,
yy = y.names_tem,
zz = z.names_tem)
}
})
x.names <- c(x.names, unlist(lapply(list_tem, function(x) unlist(x[1]))))
y.names <- c(y.names, unlist(lapply(list_tem, function(x) unlist(x[2]))))
z.names <- c(z.names, unlist(lapply(list_tem, function(x) unlist(x[3]))))
}
}
message("Detecting List1 in STRING")
map1 = string_db_list[[1]]$map( data.frame(UNIPROT_AC = unique(x.names)) ,
"UNIPROT_AC" , removeUnmappedRows = TRUE)
if( nrow(map1) == 0 ) {
stop("None of the proteins in list1 mapped to STRING ID")
}
message("Detecting List2 in STRING")
map2 = string_db_list[[2]]$map( data.frame(UNIPROT_AC = unique(y.names)) ,
"UNIPROT_AC" , removeUnmappedRows = TRUE)
if( nrow(map2) == 0 ) {
stop("None of the proteins in list2 mapped to STRING ID")
}
message("Detecting List3 in STRING")
map3 = string_db_list[[3]]$map(data.frame(UNIPROT_AC = unique(z.names)) ,
"UNIPROT_AC" , removeUnmappedRows = TRUE)
if( nrow(map3) == 0 ) {
stop("None of the proteins in list3 mapped to STRING ID")
}
OPS = data.frame(node1 = x.names, node2 = y.names, node3 = z.names)
OPS <- merge(OPS, map1, by.y = "UNIPROT_AC", by.x = "node1")
colnames(OPS)[4] <- "STRING_id_1"
OPS <- merge(OPS, map2, by.y = "UNIPROT_AC", by.x = "node2")
colnames(OPS)[5] <- "STRING_id_2"
OPS <- merge(OPS, map3, by.y = "UNIPROT_AC", by.x = "node3")
colnames(OPS)[6] <- "STRING_id_3"
OPS <- data.frame(node1 = OPS[, 4], node2 = OPS[, 5], node3 = OPS[, 6])
OPSLabel = c()
flag_tem <- TRUE
if (nrow(OPS) > 10) {OPSLabel = c(OPSLabel,paste("OPS000", c(1 : 9), sep=""))
} else {
OPSLabel = c(OPSLabel,paste("OPS000", c(1 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
if (nrow(OPS) > 100) {OPSLabel = c(OPSLabel,paste("OPS00", c(10 : 99), sep=""))
} else {
if (flag_tem) OPSLabel = c(OPSLabel,paste("OPS00", c(10 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
if (nrow(OPS) > 1000) {OPSLabel = c(OPSLabel,paste("OPS00", c(100 : 999), sep=""))
} else {
if (flag_tem) OPSLabel = c(OPSLabel,paste("OPS00", c(100 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
if (nrow(OPS) > 10000) {OPSLabel = c(OPSLabel,paste("OPS00", c(1000 : 9999), sep=""))
} else {
if (flag_tem) OPSLabel = c(OPSLabel,paste("OPS00", c(1000 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
OPS <- cbind(OPS, OPSLabel = OPSLabel)
message("Step 4/4: Retrieving String Network...")
message("Retrieving List1")
Network1 = data.frame(from = string_db_list[[1]]$get_interactions(OPS$node1)$from,
to = string_db_list[[1]]$get_interactions(OPS$node1)$to)
if(nrow(Network1) == 0){
print(ProteinLists[[1]])
stop("No interaction was detected for ProteinLists1")
}
message("Retrieving List2")
Network2 = data.frame(from = string_db_list[[2]]$get_interactions(OPS$node2)$from,
to = string_db_list[[2]]$get_interactions(OPS$node2)$to)
if(nrow(Network2) == 0){
print(ProteinLists[[2]])
stop("No interaction was detected for ProteinLists2")
}
message("Retrieving List3")
Network3 = data.frame(from = string_db_list[[3]]$get_interactions(OPS$node3)$from,
to = string_db_list[[3]]$get_interactions(OPS$node3)$to)
if(nrow(Network3) == 0){
print(ProteinLists[[3]])
stop("No interaction was detected for ProteinLists3")
}
message("Producing IPN...")
node1 = c()
node2 = c()
l = nrow(OPS)
# i = 1
for (i in seq_len(l - 1)) {
node_tem <- apply(OPS[c((i + 1) : l), ], 1, function(x){
a = c(as.character(OPS[i,1]) , as.character(x[1]))
b = c(as.character(OPS[i,2]) , as.character(x[2]))
c = c(as.character(OPS[i,3]) , as.character(x[3]))
cond1 = ifelse(nrow(Network1[((Network1$from == a[1]) & (Network1$to) == a[2]), ]) != 0 |
nrow(Network1[((Network1$from == a[2]) & (Network1$to) == a[1]), ]) != 0, TRUE, FALSE)
cond2 = ifelse(nrow(Network2[((Network2$from == b[1]) & (Network2$to) == b[2]), ]) != 0 |
nrow(Network2[((Network2$from == b[2]) & (Network2$to) == b[1]), ]) != 0, TRUE, FALSE)
cond3 = ifelse(nrow(Network3[((Network3$from == c[1]) & (Network3$to) == c[2]), ]) != 0 |
nrow(Network3[((Network3$from == c[2]) & (Network3$to) == c[1]), ]) != 0, TRUE, FALSE)
if (((cond1 + cond2 + cond3 == 1) & (coverage == 1)) |
((cond1 + cond2 + cond3 == 2) & (coverage == 2)) |
((cond1 + cond2 + cond3 == 3) & (coverage ==3))) {
return(c(as.character(OPS[i,4]), as.character(x[4])))
}
if ((NetworkShrinkage == FALSE)) {
t1 = as.character(OPS[i,1]) == as.character(x[1])
t2 = as.character(OPS[i,2]) == as.character(x[2])
t3 = as.character(OPS[i,3]) == as.character(x[3])
mycond = cond1 + cond2 + cond3
TT = t1 + t2 + t3
if (TT+mycond >= coverage){
return(c(as.character(OPS[i,4]), as.character(x[4])))
}
}
})
if (! is.null(node_tem)) {
node1 <- c(node1, unlist(node_tem)[seq(1, length(unlist(node_tem)), 2)])
node2 <- c(node2, unlist(node_tem)[seq(2, length(unlist(node_tem)), 2)])
}
}
EdgeList = data.frame(node1 , node2) #, node3)
map_list <- list(map1, map2, map3)
network_list <- list(Network1, Network2, Network3)
}
if (list_num == 2) {
x <- rep(names(tem_list[[1]]), unlist(lapply(tem_list[[1]], length)))
xperim = unlist(tem_list[[1]])
message("Detecting List1 in STRING")
map1 = string_db_list[[1]]$map(data.frame(UNIPROT_AC = unique(x)) ,
"UNIPROT_AC" , removeUnmappedRows = TRUE)
if ( nrow(map1) == 0 ) {
stop("None of the proteins in list1 mapped to STRING ID")
}
message("Detecting List2 in STRING")
map2 = string_db_list[[2]]$map( data.frame(UNIPROT_AC = unique(xperim)) ,
"UNIPROT_AC" , removeUnmappedRows = TRUE)
if (nrow(map2) == 0) {
stop("None of the proteins in list2 mapped to STRING ID")
}
OPS = data.frame(node1 = x, node2 = xperim)
OPS <- merge(OPS, map1, by.y = "UNIPROT_AC", by.x = "node1")
colnames(OPS)[3] <- "STRING_id_1"
OPS <- merge(OPS, map2, by.y = "UNIPROT_AC", by.x = "node2")
colnames(OPS)[4] <- "STRING_id_2"
OPS <- data.frame(node1 = OPS[, 3], node2 = OPS[, 4])
OPSLabel = c()
flag_tem <- TRUE
if (nrow(OPS) > 10) {OPSLabel = c(OPSLabel, paste("OPS000", c(1 : 9), sep=""))
} else {
OPSLabel = c(OPSLabel,paste("OPS000", c(1 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
if (nrow(OPS) > 100) {OPSLabel = c(OPSLabel, paste("OPS00", c(10 : 99), sep=""))
} else {
if (flag_tem) OPSLabel = c(OPSLabel, paste("OPS00", c(10 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
if (nrow(OPS) > 1000) {OPSLabel = c(OPSLabel, paste("OPS00", c(100 : 999), sep=""))
} else {
if (flag_tem) OPSLabel = c(OPSLabel,paste("OPS00", c(100 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
if (nrow(OPS) > 10000) {OPSLabel = c(OPSLabel,paste("OPS00", c(1000 : 9999), sep=""))
} else {
if (flag_tem) OPSLabel = c(OPSLabel,paste("OPS00", c(1000 : nrow(OPS)), sep=""))
flag_tem <- FALSE
}
OPS <- cbind(OPS, OPSLabel = OPSLabel)
message("Step 4/4: Retrieving String Network...")
message("Retrieving List1")
Network1 = data.frame(from = string_db_list[[1]]$get_interactions(OPS$node1)$from,
to = string_db_list[[1]]$get_interactions(OPS$node1)$to)
if (nrow(Network1) == 0) {
print(ProteinLists[[1]])
stop("No STRING network was detected for ProteinLists1")
}
message("Retrieving List2")
Network2 = data.frame(from = string_db_list[[2]]$get_interactions(OPS$node2)$from,
to = string_db_list[[2]]$get_interactions(OPS$node2)$to)
if (nrow(Network2) == 0) {
print(ProteinLists[[2]])
stop("No STRING network was detected for ProteinLists2")
}
message("Producing IPN...")
node1 = c()
node2 = c()
l = nrow(OPS)
# i = 1
for (i in seq_len((l - 1))) {
node_tem <- apply(OPS[c((i + 1) : l), ], 1, function(x){
a = c(as.character(OPS[i,1]) , as.character(x[1]))
b = c(as.character(OPS[i,2]) , as.character(x[2]))
cond1 = ifelse(nrow(Network1[((Network1$from == a[1]) & (Network1$to) == a[2]), ]) != 0 |
nrow(Network1[((Network1$from == a[2]) & (Network1$to) == a[1]), ]) != 0, TRUE, FALSE)
cond2 = ifelse(nrow(Network2[((Network2$from == b[1]) & (Network2$to) == b[2]), ]) != 0 |
nrow(Network2[((Network2$from == b[2]) & (Network2$to) == b[1]), ]) != 0, TRUE, FALSE)
if (((cond1+cond2 == 1) & (coverage == 1)) | ((cond1+cond2 == 2) & (coverage == 2))) {
return(c(as.character(OPS[i,3]), as.character(x[3])))
}
if ((NetworkShrinkage == FALSE)) {
t1 = as.character(OPS[i,1]) == as.character(x[1])
t2 = as.character(OPS[i,2]) == as.character(x[2])
mycond = cond1 + cond2
TT = t1 + t2
if (TT+mycond >= coverage){
return(c(as.character(OPS[i,3]), as.character(x[3])))
}
}
})
if (! is.null(node_tem)) {
node1 <- c(node1, unlist(node_tem)[seq(1, length(unlist(node_tem)), 2)])
node2 <- c(node2, unlist(node_tem)[seq(2, length(unlist(node_tem)), 2)])
}
}
EdgeList = data.frame(node1 , node2)
map_list <- list(map1, map2)
network_list <- list(Network1, Network2)
}
if (nrow(EdgeList) != 0) {
IPN = graph_from_data_frame(d = EdgeList, directed = FALSE)
reslist = list(IPNEdges = EdgeList , IPNNodes = OPS,
Networks = network_list,
maps = map_list)
plot(IPN, layout = layout_in_circle(IPN))
message("DONE!")
return(reslist)
}
if (nrow(EdgeList) == 0) {
reslist = list(IPNEdges = EdgeList , IPNNodes = OPS,
Networks = network_list,
maps = map_list)
message("DONE! But EdgeList is empty!")
return(reslist)
}
}
library(igraph)
library(Biostrings)
library(seqinr)
library(STRINGdb)
data(H.sapiens)
data(R.norvegicus)
data(Celegance)
data(FruitFly)
ProteinLists = list(as.character(H.sapiens$V1), as.character(R.norvegicus$V1),
as.character(Celegance$V1), as.character(FruitFly$V1))
List1_Species_ID = 9606  # taxonomy ID List1 Homo sapiens
List2_Species_ID = 10116 # taxonomy ID List2 Rat
List3_Species_ID = 6239  # taxonomy ID List3 Celegance
List4_Species_ID = 7227  # taxonomy ID List4 FruitFly
Species_IDs  = c(List1_Species_ID, List2_Species_ID, List3_Species_ID, List4_Species_ID)
devtools::use_testthat()
devtools::test()
library(testthat)
library(IMMAN)
test_check("IMMAN")
data("H.sapiens")
data("R.norvegicus")
test_that("IMMAN reconstruct the interlog protein network", {
IMMAN(ProteinLists=list(as.character(H.sapiens$V1), as.character(R.norvegicus$V1)), fileNames=NULL, Species_IDs,
identityU = 30,
substitutionMatrix = "BLOSUM62",
gapOpening = -8,
gapExtension = -8,
NetworkShrinkage = FALSE,
coverage = 1,
BestHit = TRUE,
score_threshold = 400,
STRINGversion="10",
InputDirectory = getwd())
})
devtools::load_all()
load_all()
devtools::load_all()
devtools::load_all()
devtools::document()
load_all()
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
load_all()
?PairwiseAlignments
library(IMMAN)
library(IMMAN)
load_all()
devtools::load_all()
devtools::load_all()
load_all()
library(IMMAN)
install.packages("rmarkdown")
efficient::test_rcpp()
library(Rcpp)
efficient::test_rcpp()
test_rcpp()
globalVariables("add_c")
#' Rcpp test function
#'
#' A simple function to test whether Rcpp is installed and working.
#' @return Returns \code{TRUE} if everything is OK.
#' @importFrom Rcpp cppFunction
#' @export
test_rcpp = function() {
cppFunction('
int add_c(int x, int y){
return x + y;
}
')
if(add_c(1, 1) == 2) {
message("Everything seems fine")
return(TRUE)
}
return(FALSE)
}
efficient::test_rcpp()
devtools::install_github("csgillespie/efficient",
args = "--with-keep.source")
efficient::test_rcpp()
devtools::document()
devtools::check()
devtools::load_all(".")
library(IMMAN)
devtools::document()
devtools::document()
devtools::load_all(".")
library(IMMAN)
devtools::document()
is_a("data.frame")
library(testthat)
?is_a
?is_igraph
?expect_that
source("IMMAN.R")
test_that("IMMAN reconstruct the interlog protein network", {
roots <- IMMAN(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("IMMAN reconstruct the interlog protein network", {
result <- IMMAN(ProteinLists=list(as.character(FruitFly$V1), as.character(R.norvegicus$V1)), fileNames=NULL, Species_IDs  = c(7227, 10116),
identityU = 30,
substitutionMatrix = "BLOSUM62",
gapOpening = -8,
gapExtension = -8,
NetworkShrinkage = FALSE,
coverage = 1,
BestHit = TRUE,
score_threshold = 400,
STRINGversion="10",
InputDirectory = getwd())
expect_that( result$IPNEdges, is_a("data.frame") )
expect_that( result$IPNNodes, is_a("data.frame") )
expect_that( result$IPN, is_igraph(result$IPN) )
})
source("IMMAN.R")
library(igraph)
test_that("IMMAN reconstruct the interlog protein network", {
result <- IMMAN(ProteinLists=list(as.character(FruitFly$V1), as.character(R.norvegicus$V1)), fileNames=NULL, Species_IDs  = c(7227, 10116),
identityU = 30,
substitutionMatrix = "BLOSUM62",
gapOpening = -8,
gapExtension = -8,
NetworkShrinkage = FALSE,
coverage = 1,
BestHit = TRUE,
score_threshold = 400,
STRINGversion="10",
InputDirectory = getwd())
expect_that( result$IPNEdges, is_a("data.frame") )
expect_that( result$IPNNodes, is_a("data.frame") )
expect_that( result$IPN, is_igraph(result$IPN) )
})
?is_a
result$IPN
source("IMMAN.R")
test_that("IMMAN reconstruct the interlog protein network", {
result <- IMMAN(ProteinLists=list(as.character(FruitFly$V1), as.character(R.norvegicus$V1)), fileNames=NULL, Species_IDs  = c(7227, 10116),
identityU = 30,
substitutionMatrix = "BLOSUM62",
gapOpening = -8,
gapExtension = -8,
NetworkShrinkage = FALSE,
coverage = 1,
BestHit = TRUE,
score_threshold = 400,
STRINGversion="10",
InputDirectory = getwd())
expect_that( result$IPNEdges, is_a("data.frame") )
expect_that( result$IPNNodes, is_a("data.frame") )
})
source("R/IMMAN.R")
source("C:/Users/MinOoO/Desktop/IMMAN/IMMAN/R/IMMAN.R")
devtools::load_all()
devtools::document()
<<<<<<< HEAD
setwd("E:/EDUCATION/Pasteur/Centrality project/10. Networks global properties/raw data")
library(igraph)
data.list<-read.table("edgelist.giant.component.barabasi.txt",header=T,sep="\t")
mat.net=as.matrix(data.list) # coerces the data into a two-column matrix format that igiant.comp likes
data.list<-read.table("edgelist.giant.component.erdos.txt",header=T,sep="\t")
mat.net=as.matrix(data.list) # coerces the data into a two-column matrix format that igiant.comp likes
rm(data.list)
rownames(mat.net) <- NULL
edge<-mat.net[,1:2]
rm(mat.net)
edge[,1]=as.character(edge[,1])
edge[,2]=as.character(edge[,2])
g=graph.edgelist(edge,directed=FALSE) # turns the edgelist into a 'graph object'
################################### Fitting degree distribution of a graph by power law ##############################
d = degree(g, mode = "all")
dd = degree.distribution(g, mode = "all", cumulative = FALSE)
# write a function to plot the degree distribution
plot_degree_distribution = function(graph) {
# calculate degree
d = degree(graph, mode = "all")
dd = degree.distribution(graph, mode = "all", cumulative = FALSE)
degree = 1:max(d)
probability = dd[-1]
# delete blank values
nonzero.position = which(probability != 0)
probability = probability[nonzero.position]
degree = degree[nonzero.position]
# plot
plot(probability ~ degree, log = "xy", xlab = "Degree (log)", ylab = "Probability (log)",
col = 1, main = "Degree Distribution")
}
plot_degree_distribution(g)
# plot and fit the power law distribution
fit_power_law = function(graph) {
# calculate degree
d = degree(graph, mode = "all")
dd = degree.distribution(graph, mode = "all", cumulative = FALSE)
degree = 1:max(d)
probability = dd[-1]
# delete blank values
nonzero.position = which(probability != 0)
probability = probability[nonzero.position]
degree = degree[nonzero.position]
reg = lm(log(probability) ~ log(degree))
cozf = coef(reg)
power.law.fit = function(x) exp(cozf[[1]] + cozf[[2]] * log(x))
alpha = -cozf[[2]]
R.square = summary(reg)$r.squared
print(paste("Alpha =", round(alpha, 3)))
print(paste("R square =", round(R.square, 3)))
# plot
plot(probability ~ degree, log = "xy", xlab = "Degree (log)", ylab = "Probability (log)",
col = 1, main = "Degree Distribution")
curve(power.law.fit, col = "red", add = T, n = length(d))
}
fit_power_law(g)
data.list<-read.table("edgelist.giant.component.erdos.txt",header=T,sep="\t")
mat.net=as.matrix(data.list) # coerces the data into a two-column matrix format that igiant.comp likes
rm(data.list)
rownames(mat.net) <- NULL
edge<-mat.net[,1:2]
rm(mat.net)
edge[,1]=as.character(edge[,1])
edge[,2]=as.character(edge[,2])
g=graph.edgelist(edge,directed=FALSE) # turns the edgelist into a 'graph object'
################################### Fitting degree distribution of a graph by power law ##############################
d = degree(g, mode = "all")
# write a function to plot the degree distribution
plot_degree_distribution = function(graph) {
# calculate degree
d = degree(graph, mode = "all")
dd = degree.distribution(graph, mode = "all", cumulative = FALSE)
degree = 1:max(d)
probability = dd[-1]
# delete blank values
nonzero.position = which(probability != 0)
probability = probability[nonzero.position]
degree = degree[nonzero.position]
# plot
plot(probability ~ degree, log = "xy", xlab = "Degree (log)", ylab = "Probability (log)",
col = 1, main = "Degree Distribution")
}
plot_degree_distribution(g)
# plot and fit the power law distribution
fit_power_law = function(graph) {
# calculate degree
d = degree(graph, mode = "all")
dd = degree.distribution(graph, mode = "all", cumulative = FALSE)
degree = 1:max(d)
probability = dd[-1]
# delete blank values
nonzero.position = which(probability != 0)
probability = probability[nonzero.position]
degree = degree[nonzero.position]
reg = lm(log(probability) ~ log(degree))
cozf = coef(reg)
power.law.fit = function(x) exp(cozf[[1]] + cozf[[2]] * log(x))
alpha = -cozf[[2]]
R.square = summary(reg)$r.squared
print(paste("Alpha =", round(alpha, 3)))
print(paste("R square =", round(R.square, 3)))
# plot
plot(probability ~ degree, log = "xy", xlab = "Degree (log)", ylab = "Probability (log)",
col = 1, main = "Degree Distribution")
curve(power.law.fit, col = "red", add = T, n = length(d))
}
fit_power_law(g)
devtools::test()
devtools::test()
=======
>>>>>>> 863e7b4394730f9b38219f7da3c5ebf89afd43b5
